-- Complete database schema for ZMF Production Dashboard
-- This migration creates all tables, indexes, functions, and RLS policies

-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- Drop existing types if they exist (for clean migration)
DROP TYPE IF EXISTS production_stage CASCADE;
DROP TYPE IF EXISTS quality_status CASCADE;
DROP TYPE IF EXISTS worker_role CASCADE;
DROP TYPE IF EXISTS batch_priority CASCADE;
DROP TYPE IF EXISTS order_status CASCADE;
DROP TYPE IF EXISTS wood_type CASCADE;
DROP TYPE IF EXISTS model_complexity CASCADE;

-- Create custom types
CREATE TYPE production_stage AS ENUM (
  'Intake',
  'Sanding',
  'Finishing',
  'Sub-Assembly',
  'Final Assembly',
  'Acoustic QC',
  'Shipping'
);

CREATE TYPE quality_status AS ENUM (
  'good',
  'warning',
  'critical',
  'hold'
);

CREATE TYPE worker_role AS ENUM (
  'worker',
  'manager',
  'admin'
);

CREATE TYPE batch_priority AS ENUM (
  'standard',
  'rush',
  'expedite'
);

CREATE TYPE order_status AS ENUM (
  'pending',
  'in_production',
  'completed',
  'shipped',
  'on_hold'
);

CREATE TYPE wood_type AS ENUM (
  'Sapele',
  'Cherry',
  'Walnut',
  'Ash',
  'Maple',
  'Cocobolo',
  'Katalox',
  'Ziricote',
  'Blackwood'
);

CREATE TYPE model_complexity AS ENUM (
  'medium',
  'high',
  'very_high'
);

-- Helper function for updated_at
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 1. User Management Tables

-- Workers table (enhanced from existing)
ALTER TABLE workers ADD COLUMN IF NOT EXISTS hire_date DATE DEFAULT CURRENT_DATE;
ALTER TABLE workers ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ DEFAULT NOW();

-- Create missing indexes
CREATE INDEX IF NOT EXISTS idx_workers_auth_user_id ON workers(auth_user_id);
CREATE INDEX IF NOT EXISTS idx_workers_email ON workers(email);
-- Check if role column exists before creating index
DO $$ 
BEGIN
  IF EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'workers' AND column_name = 'role'
  ) THEN
    CREATE INDEX IF NOT EXISTS idx_workers_role ON workers(role) WHERE is_active = true;
  END IF;
END $$;
-- Check if specializations column exists before creating index
DO $$ 
BEGIN
  IF EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'workers' AND column_name = 'specializations'
  ) THEN
    CREATE INDEX IF NOT EXISTS idx_workers_specializations ON workers USING GIN(specializations);
  END IF;
END $$;

-- Add updated_at trigger
DROP TRIGGER IF EXISTS update_workers_updated_at ON workers;
CREATE TRIGGER update_workers_updated_at BEFORE UPDATE ON workers
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

-- 2. Product Management Tables

-- Enhance headphone_models table
ALTER TABLE headphone_models ADD COLUMN IF NOT EXISTS sku_prefix TEXT UNIQUE;
ALTER TABLE headphone_models ADD COLUMN IF NOT EXISTS base_price DECIMAL(10,2);
ALTER TABLE headphone_models ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ DEFAULT NOW();

-- Add constraints
ALTER TABLE headphone_models ADD CONSTRAINT check_base_hours CHECK (base_production_hours > 0);
ALTER TABLE headphone_models ADD CONSTRAINT check_base_price CHECK (base_price > 0);
ALTER TABLE headphone_models ADD CONSTRAINT check_wood_types CHECK (array_length(wood_types, 1) > 0);

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_models_active ON headphone_models(is_active);
CREATE INDEX IF NOT EXISTS idx_models_wood_types ON headphone_models USING GIN(wood_types);

-- Model production stages
CREATE TABLE IF NOT EXISTS model_production_stages (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  model_id UUID REFERENCES headphone_models(id) ON DELETE CASCADE,
  stage production_stage NOT NULL,
  estimated_hours DECIMAL(4,2) NOT NULL CHECK (estimated_hours > 0),
  quality_checklist JSONB NOT NULL DEFAULT '[]',
  display_order INTEGER NOT NULL,
  is_required BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  CONSTRAINT unique_model_stage UNIQUE(model_id, stage)
);

CREATE INDEX IF NOT EXISTS idx_model_stages ON model_production_stages(model_id, display_order);

-- 3. Customer & Order Management

-- Enhance customers table
ALTER TABLE customers ADD COLUMN IF NOT EXISTS shipping_address JSONB;
ALTER TABLE customers ADD COLUMN IF NOT EXISTS billing_address JSONB;
ALTER TABLE customers ADD COLUMN IF NOT EXISTS notes TEXT;
ALTER TABLE customers ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ DEFAULT NOW();

CREATE INDEX IF NOT EXISTS idx_customers_email ON customers(email);
CREATE INDEX IF NOT EXISTS idx_customers_shopify_id ON customers(shopify_customer_id) WHERE shopify_customer_id IS NOT NULL;

-- Enhance orders table
ALTER TABLE orders ADD COLUMN IF NOT EXISTS due_date DATE;

CREATE INDEX IF NOT EXISTS idx_orders_status ON orders(status) WHERE status != 'shipped';
CREATE INDEX IF NOT EXISTS idx_orders_customer ON orders(customer_id);
CREATE INDEX IF NOT EXISTS idx_orders_model ON orders(model_id);
CREATE INDEX IF NOT EXISTS idx_orders_due_date ON orders(due_date) WHERE status IN ('pending', 'in_production');
CREATE INDEX IF NOT EXISTS idx_orders_created ON orders(created_at DESC);

-- Order status history
CREATE TABLE IF NOT EXISTS order_status_history (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  order_id UUID REFERENCES orders(id) ON DELETE CASCADE,
  old_status order_status,
  new_status order_status NOT NULL,
  changed_by UUID REFERENCES workers(id),
  reason TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_order_history ON order_status_history(order_id, created_at DESC);

-- 4. Production Management

-- Enhance batches table
ALTER TABLE batches ADD COLUMN IF NOT EXISTS target_completion DATE;
ALTER TABLE batches ADD COLUMN IF NOT EXISTS actual_completion DATE;
ALTER TABLE batches ADD COLUMN IF NOT EXISTS created_by UUID REFERENCES workers(id);

CREATE INDEX IF NOT EXISTS idx_batches_active ON batches(is_complete, current_stage) WHERE is_complete = false;
CREATE INDEX IF NOT EXISTS idx_batches_priority ON batches(priority, created_at) WHERE is_complete = false;

-- Enhance batch_orders
ALTER TABLE batch_orders ADD COLUMN IF NOT EXISTS added_at TIMESTAMPTZ DEFAULT NOW();
ALTER TABLE batch_orders ADD COLUMN IF NOT EXISTS added_by UUID REFERENCES workers(id);

CREATE INDEX IF NOT EXISTS idx_batch_orders_order ON batch_orders(order_id);

-- Ensure orders aren't in multiple active batches
CREATE UNIQUE INDEX IF NOT EXISTS idx_single_active_batch ON batch_orders(order_id)
WHERE EXISTS (
  SELECT 1 FROM batches 
  WHERE batches.id = batch_orders.batch_id 
  AND NOT batches.is_complete
);

-- Enhance stage_assignments
ALTER TABLE stage_assignments ADD COLUMN IF NOT EXISTS notes TEXT;

-- Add time_spent as generated column
ALTER TABLE stage_assignments DROP COLUMN IF EXISTS time_spent_minutes;
ALTER TABLE stage_assignments ADD COLUMN time_spent_minutes INTEGER GENERATED ALWAYS AS (
  CASE 
    WHEN completed_at IS NOT NULL AND started_at IS NOT NULL 
    THEN EXTRACT(EPOCH FROM (completed_at - started_at)) / 60
    ELSE NULL
  END
) STORED;

CREATE INDEX IF NOT EXISTS idx_assignments_batch ON stage_assignments(batch_id);
CREATE INDEX IF NOT EXISTS idx_assignments_worker ON stage_assignments(assigned_worker_id);
CREATE INDEX IF NOT EXISTS idx_assignments_active ON stage_assignments(completed_at) WHERE completed_at IS NULL;

-- Production schedules
CREATE TABLE IF NOT EXISTS production_schedules (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  batch_id UUID REFERENCES batches(id) ON DELETE CASCADE,
  stage production_stage NOT NULL,
  scheduled_date DATE NOT NULL,
  assigned_worker_id UUID REFERENCES workers(id),
  estimated_hours DECIMAL(4,2),
  actual_start TIMESTAMPTZ,
  actual_end TIMESTAMPTZ,
  status TEXT CHECK (status IN ('scheduled', 'in_progress', 'completed', 'delayed')),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(batch_id, stage)
);

CREATE INDEX IF NOT EXISTS idx_schedules_date ON production_schedules(scheduled_date, status);
CREATE INDEX IF NOT EXISTS idx_schedules_worker ON production_schedules(assigned_worker_id, scheduled_date);

-- 5. Quality Control Tables

-- Quality checklist templates
CREATE TABLE IF NOT EXISTS quality_checklist_templates (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  model_id UUID REFERENCES headphone_models(id),
  stage production_stage NOT NULL,
  version INTEGER DEFAULT 1,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES workers(id),
  CONSTRAINT unique_active_template UNIQUE(model_id, stage) WHERE is_active = true
);

-- Checklist items
CREATE TABLE IF NOT EXISTS quality_checklist_items (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  template_id UUID REFERENCES quality_checklist_templates(id) ON DELETE CASCADE,
  category TEXT NOT NULL,
  item_text TEXT NOT NULL,
  severity quality_status NOT NULL DEFAULT 'warning',
  is_required BOOLEAN DEFAULT true,
  display_order INTEGER NOT NULL,
  help_text TEXT,
  photo_required BOOLEAN DEFAULT false
);

CREATE INDEX IF NOT EXISTS idx_checklist_items ON quality_checklist_items(template_id, display_order);

-- Enhanced quality checks
ALTER TABLE quality_checks ADD COLUMN IF NOT EXISTS template_id UUID REFERENCES quality_checklist_templates(id);
ALTER TABLE quality_checks ADD COLUMN IF NOT EXISTS duration_minutes INTEGER;
ALTER TABLE quality_checks ADD COLUMN IF NOT EXISTS completed_at TIMESTAMPTZ;

-- Add unique constraint
ALTER TABLE quality_checks DROP CONSTRAINT IF EXISTS unique_order_stage_check;
ALTER TABLE quality_checks ADD CONSTRAINT unique_order_stage_check UNIQUE(order_id, stage);

CREATE INDEX IF NOT EXISTS idx_checks_order ON quality_checks(order_id);
CREATE INDEX IF NOT EXISTS idx_checks_batch ON quality_checks(batch_id);
CREATE INDEX IF NOT EXISTS idx_checks_worker ON quality_checks(worker_id);
CREATE INDEX IF NOT EXISTS idx_checks_status ON quality_checks(overall_status) WHERE overall_status != 'good';

-- Individual check results
CREATE TABLE IF NOT EXISTS quality_check_results (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  quality_check_id UUID REFERENCES quality_checks(id) ON DELETE CASCADE,
  checklist_item_id UUID REFERENCES quality_checklist_items(id),
  passed BOOLEAN NOT NULL,
  notes TEXT,
  photo_urls TEXT[]
);

CREATE INDEX IF NOT EXISTS idx_check_results ON quality_check_results(quality_check_id);

-- 6. Issue Tracking

-- Issue categories
CREATE TABLE IF NOT EXISTS issue_categories (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  name TEXT NOT NULL UNIQUE,
  description TEXT,
  default_severity quality_status NOT NULL,
  sla_hours INTEGER,
  is_active BOOLEAN DEFAULT true
);

-- Enhance issues table
ALTER TABLE issues ADD COLUMN IF NOT EXISTS root_cause TEXT;
ALTER TABLE issues ADD COLUMN IF NOT EXISTS photo_urls TEXT[];

-- Add due date based on SLA
ALTER TABLE issues DROP COLUMN IF EXISTS due_at;
ALTER TABLE issues ADD COLUMN due_at TIMESTAMPTZ GENERATED ALWAYS AS (
  created_at + COALESCE(
    (SELECT sla_hours || ' hours'::INTERVAL FROM issue_categories WHERE id = issues.category_id),
    '24 hours'::INTERVAL
  )
) STORED;

CREATE INDEX IF NOT EXISTS idx_issues_open ON issues(is_resolved, severity) WHERE is_resolved = false;
CREATE INDEX IF NOT EXISTS idx_issues_order ON issues(order_id);
CREATE INDEX IF NOT EXISTS idx_issues_assigned ON issues(assigned_to) WHERE is_resolved = false;
CREATE INDEX IF NOT EXISTS idx_issues_due ON issues(due_at) WHERE is_resolved = false;

-- Issue comments
CREATE TABLE IF NOT EXISTS issue_comments (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  issue_id UUID REFERENCES issues(id) ON DELETE CASCADE,
  author_id UUID REFERENCES workers(id),
  comment_text TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_issue_comments ON issue_comments(issue_id, created_at);

-- 7. Performance Tracking

-- Production metrics (already exists)
CREATE INDEX IF NOT EXISTS idx_metrics_worker_date ON production_metrics(worker_id, date DESC);
CREATE INDEX IF NOT EXISTS idx_metrics_date ON production_metrics(date DESC);

-- Worker availability
CREATE TABLE IF NOT EXISTS worker_availability (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  worker_id UUID REFERENCES workers(id) ON DELETE CASCADE,
  date DATE NOT NULL,
  available_hours DECIMAL(3,1) DEFAULT 8.0 CHECK (available_hours BETWEEN 0 AND 24),
  assigned_hours DECIMAL(3,1) DEFAULT 0.0 CHECK (assigned_hours BETWEEN 0 AND 24),
  notes TEXT,
  CONSTRAINT unique_worker_date UNIQUE(worker_id, date),
  CONSTRAINT valid_hours CHECK (assigned_hours <= available_hours)
);

CREATE INDEX IF NOT EXISTS idx_availability_date ON worker_availability(date, worker_id);

-- 8. System Logging

-- Enhance system_logs
CREATE INDEX IF NOT EXISTS idx_logs_user ON system_logs(user_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_logs_date ON system_logs(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_logs_action ON system_logs(action, created_at DESC);

-- 9. Create storage buckets
INSERT INTO storage.buckets (id, name, public)
VALUES ('quality-photos', 'quality-photos', false)
ON CONFLICT (id) DO NOTHING;

-- 10. Helper Functions

-- Generate batch number
CREATE OR REPLACE FUNCTION generate_batch_number()
RETURNS TEXT AS $$
DECLARE
  today_count INTEGER;
  batch_number TEXT;
BEGIN
  SELECT COUNT(*) + 1 INTO today_count
  FROM batches
  WHERE DATE(created_at) = CURRENT_DATE;
  
  batch_number := 'B' || TO_CHAR(CURRENT_DATE, 'YYYYMMDD') || '-' || LPAD(today_count::TEXT, 3, '0');
  
  RETURN batch_number;
END;
$$ LANGUAGE plpgsql;

-- Calculate batch progress
CREATE OR REPLACE FUNCTION calculate_batch_progress(batch_uuid UUID)
RETURNS TABLE (
  total_stages INTEGER,
  completed_stages INTEGER,
  progress_percentage DECIMAL(5,2),
  estimated_remaining_hours DECIMAL(6,2)
) AS $$
BEGIN
  RETURN QUERY
  WITH stage_counts AS (
    SELECT 
      COUNT(DISTINCT sa.stage) as total,
      COUNT(DISTINCT CASE WHEN sa.completed_at IS NOT NULL THEN sa.stage END) as completed
    FROM stage_assignments sa
    WHERE sa.batch_id = batch_uuid
  ),
  remaining_hours AS (
    SELECT 
      SUM(mps.estimated_hours) as hours
    FROM batch_orders bo
    JOIN orders o ON bo.order_id = o.id
    JOIN model_production_stages mps ON o.model_id = mps.model_id
    LEFT JOIN stage_assignments sa ON sa.batch_id = bo.batch_id AND sa.stage = mps.stage
    WHERE bo.batch_id = batch_uuid
    AND sa.completed_at IS NULL
  )
  SELECT 
    sc.total::INTEGER,
    sc.completed::INTEGER,
    CASE 
      WHEN sc.total > 0 THEN ROUND((sc.completed::DECIMAL / sc.total::DECIMAL) * 100, 2)
      ELSE 0
    END as progress_percentage,
    COALESCE(rh.hours, 0) as estimated_remaining_hours
  FROM stage_counts sc, remaining_hours rh;
END;
$$ LANGUAGE plpgsql;

-- Get available workers for a stage
CREATE OR REPLACE FUNCTION get_available_workers(
  p_stage production_stage,
  p_date DATE
)
RETURNS TABLE (
  worker_id UUID,
  worker_name TEXT,
  available_hours DECIMAL(3,1),
  skill_level TEXT
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    w.id,
    w.name,
    COALESCE(wa.available_hours - wa.assigned_hours, 8.0) as available_hours,
    CASE 
      WHEN AVG(pm.quality_pass_rate) > 95 THEN 'expert'
      WHEN AVG(pm.quality_pass_rate) > 85 THEN 'skilled'
      ELSE 'standard'
    END as skill_level
  FROM workers w
  LEFT JOIN worker_availability wa ON w.id = wa.worker_id AND wa.date = p_date
  LEFT JOIN production_metrics pm ON w.id = pm.worker_id AND pm.stage = p_stage
  WHERE 
    w.is_active = true
    AND p_stage = ANY(w.specializations)
    AND COALESCE(wa.available_hours - wa.assigned_hours, 8.0) > 0
  GROUP BY w.id, w.name, wa.available_hours, wa.assigned_hours
  ORDER BY skill_level DESC, available_hours DESC;
END;
$$ LANGUAGE plpgsql;

-- 11. Update all triggers
CREATE TRIGGER update_orders_updated_at BEFORE UPDATE ON orders
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

CREATE TRIGGER update_batches_updated_at BEFORE UPDATE ON batches
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

CREATE TRIGGER update_customers_updated_at BEFORE UPDATE ON customers
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

CREATE TRIGGER update_headphone_models_updated_at BEFORE UPDATE ON headphone_models
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

CREATE TRIGGER update_production_schedules_updated_at BEFORE UPDATE ON production_schedules
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

-- 12. Initial data fixes
UPDATE headphone_models SET 
  sku_prefix = UPPER(LEFT(name, 3)),
  base_price = CASE 
    WHEN complexity = 'medium' THEN 599.00
    WHEN complexity = 'high' THEN 2499.00
    WHEN complexity = 'very_high' THEN 3499.00
  END
WHERE sku_prefix IS NULL OR base_price IS NULL;

-- 13. Create default issue categories
INSERT INTO issue_categories (name, description, default_severity, sla_hours) VALUES
  ('Wood Defect', 'Issues with wood quality or appearance', 'warning', 24),
  ('Assembly Error', 'Problems with component assembly', 'critical', 4),
  ('Finish Quality', 'Issues with finishing or coating', 'warning', 12),
  ('Acoustic Issue', 'Sound quality problems', 'critical', 2),
  ('Cosmetic Damage', 'Scratches, dents, or other visual damage', 'warning', 24),
  ('Missing Parts', 'Components missing from order', 'critical', 1),
  ('Wrong Configuration', 'Order built with incorrect specifications', 'hold', 1)
ON CONFLICT (name) DO NOTHING;

-- 14. Grant permissions for service role
GRANT ALL ON ALL TABLES IN SCHEMA public TO service_role;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO service_role;
GRANT ALL ON ALL FUNCTIONS IN SCHEMA public TO service_role;